import React, { useState, useCallback, useRef, useEffect } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import axios from 'axios';
import { ChatPanel } from '../components/agent/ChatPanel';
import { PreviewPanel } from '../components/preview/PreviewPanel';
import { PlanningReview } from '../components/agent/PlanningReview';
import { AgentMessageData, MessageType } from '../components/agent/AgentMessage';
import { ProcessingPhase } from '../components/agent/ProcessingStep';
import { AgentStatusType } from '../components/agent/AgentStatus';
import { FileNode } from '../components/preview/FileTree';
import { BACKEND_URL } from '../config';
import { useWebContainer } from '../hooks/useWebContainer.tsx';
import { parseStackTrace } from '../utils/errorReporter';
import type { ProjectBlueprint } from '../types/planning.types';
import { ArrowLeft, Sparkles, Loader2, Zap, FolderOpen } from 'lucide-react';
import type { FileSystemTree } from '@webcontainer/api';

const MAX_FIX_ATTEMPTS = 15;

// Helper to convert flat file list to tree structure
const buildFileTree = (files: { path: string; content: string }[]): FileNode[] => {
    const root: FileNode[] = [];

    files.forEach(file => {
        const parts = file.path.replace(/^\//, '').split('/');
        let current = root;
        let currentPath = '';

        parts.forEach((part, index) => {
            currentPath += '/' + part;
            const isFile = index === parts.length - 1;

            let existing = current.find(n => n.name === part);

            if (!existing) {
                existing = {
                    name: part,
                    path: currentPath,
                    type: isFile ? 'file' : 'folder',
                    children: isFile ? undefined : [],
                    content: isFile ? file.content : undefined
                };
                current.push(existing);
            }

            if (!isFile && existing.children) {
                current = existing.children;
            }
        });
    });

    // Sort: folders first, then files alphabetically
    const sortNodes = (nodes: FileNode[]): FileNode[] => {
        return nodes.sort((a, b) => {
            if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;
            return a.name.localeCompare(b.name);
        }).map(node => ({
            ...node,
            children: node.children ? sortNodes(node.children) : undefined
        }));
    };

    return sortNodes(root);
};

// Convert flat files to WebContainer FileSystemTree format
const toWebContainerFS = (files: { path: string; content: string }[]): FileSystemTree => {
    const tree: FileSystemTree = {};

    for (const file of files) {
        const pathParts = file.path.replace(/^\//, '').split('/');
        let current: any = tree;

        for (let i = 0; i < pathParts.length; i++) {
            const part = pathParts[i];
            const isLast = i === pathParts.length - 1;

            if (isLast) {
                current[part] = { file: { contents: file.content } };
            } else {
                if (!current[part]) {
                    current[part] = { directory: {} };
                }
                current = current[part].directory;
            }
        }
    }

    return tree;
};

export const AgentBuilder: React.FC = () => {
    const navigate = useNavigate();

    // Use the enhanced WebContainer hook with all features
    const {
        isBooting,
        isInstalling,
        isRunning,
        previewUrl: wcPreviewUrl,
        error: wcError,
        terminalOutput,
        isPreWarmed,
        isPreWarming,
        mountFiles,
        startDevServer,
        updateFile,
        reset: resetWebContainer,
    } = useWebContainer();

    // State
    const [messages, setMessages] = useState<AgentMessageData[]>([]);
    const [phases, setPhases] = useState<ProcessingPhase[]>([
        { id: 'blueprint', name: 'Generating blueprint', status: 'pending' },
        { id: 'core', name: 'Creating core files', status: 'pending' },
        { id: 'components', name: 'Building components', status: 'pending', filesCreated: 0 },
        { id: 'pages', name: 'Creating pages', status: 'pending', filesCreated: 0 },
        { id: 'repair', name: 'Validation & repair', status: 'pending' }
    ]);
    const [status, setStatus] = useState<AgentStatusType>('idle');
    const [statusMessage, setStatusMessage] = useState<string>();
    const [isProcessing, setIsProcessing] = useState(false);

    const [files, setFiles] = useState<{ path: string; content: string }[]>([]);
    const [fileTree, setFileTree] = useState<FileNode[]>([]);
    const [selectedFile, setSelectedFile] = useState<FileNode | null>(null);

    // Auto-fix state
    const [isFixing, setIsFixing] = useState(false);
    const [fixCount, setFixCount] = useState(0);
    const fixingRef = useRef(false);
    const fixAttempts = useRef(0);
    const filesRef = useRef<{ path: string; content: string }[]>([]);
    const fixedFilesRef = useRef<Map<string, number>>(new Map()); // Time-based cooldown tracking

    // Planning review state
    const [showPlanningReview, setShowPlanningReview] = useState(false);
    const [blueprint, setBlueprint] = useState<ProjectBlueprint | null>(null);
    const [pendingPrompt, setPendingPrompt] = useState<string>('');
    const [projectId, setProjectId] = useState<string | null>(null);

    const abortControllerRef = useRef<AbortController | null>(null);
    const [searchParams] = useSearchParams();
    const [isLoadingProject, setIsLoadingProject] = useState(false);

    // Load project from URL parameter on mount
    useEffect(() => {
        const projectIdFromUrl = searchParams.get('project');
        if (projectIdFromUrl && !projectId && files.length === 0 && !isLoadingProject) {
            loadProject(projectIdFromUrl);
        }
    }, [searchParams]);

    // Function to load a project from the API
    const loadProject = async (id: string) => {
        setIsLoadingProject(true);
        setStatusMessage('Loading project...');

        // Reset WebContainer to stop any running processes
        resetWebContainer();

        try {
            const response = await axios.get(`${BACKEND_URL}/api/projects/${id}`);
            const project = response.data.project;

            console.log('üì¶ [LOAD PROJECT] Project loaded from API:', {
                id: project._id,
                name: project.name,
                fileCount: project.files?.length,
                samplePaths: project.files?.slice(0, 5).map((f: any) => f.path)
            });

            if (project && project.files) {
                // Set project ID
                setProjectId(id);

                // Set files with path normalization
                // Fix paths for projects that have React files at root instead of /src/
                const projectFiles = project.files.map((f: any) => {
                    let path = f.path.startsWith('/') ? f.path : '/' + f.path;

                    // Check if this is a React file that should be under /src/
                    const isReactFile = path.endsWith('.tsx') || path.endsWith('.jsx');
                    const isAtRoot = !path.startsWith('/src/') && !path.startsWith('/public/');
                    const isConfigFile = ['vite.config.ts', 'tailwind.config.js', 'tsconfig.json', 'package.json', 'index.html', 'postcss.config.js'].some(cfg => path.endsWith(cfg));

                    // If it's a React file at root (not a config), move it to /src/
                    if (isReactFile && isAtRoot && !isConfigFile) {
                        const newPath = '/src' + path;
                        console.log(`üìÇ [PATH FIX] Moving to src: ${path} -> ${newPath}`);
                        path = newPath;
                    }
                    // If it's a folder like /components, /pages, /lib at root, prefix with /src
                    if (isAtRoot && !isConfigFile && (path.startsWith('/components/') || path.startsWith('/pages/') || path.startsWith('/lib/') || path.startsWith('/hooks/'))) {
                        const newPath = '/src' + path;
                        console.log(`üìÇ [PATH FIX] Moving folder to src: ${path} -> ${newPath}`);
                        path = newPath;
                    }

                    return { path, content: f.content };
                });
                setFiles(projectFiles);

                console.log('üìÅ [LOAD PROJECT] Files mapped:', {
                    count: projectFiles.length,
                    paths: projectFiles.map((f: any) => f.path).slice(0, 10),
                    hasMainTsx: projectFiles.some((f: any) => f.path.includes('main.tsx')),
                    hasAppTsx: projectFiles.some((f: any) => f.path.includes('App.tsx')),
                    hasPackageJson: projectFiles.some((f: any) => f.path.includes('package.json'))
                });

                // Build file tree
                const tree = buildFileTree(projectFiles);
                setFileTree(tree);

                // Set blueprint if available
                if (project.blueprint) {
                    setBlueprint(project.blueprint);
                }

                // Set prompt
                if (project.prompt) {
                    setPendingPrompt(project.prompt);
                }

                // Add success message (inline since addMessage not defined yet)
                setMessages(prev => [...prev, {
                    id: Date.now().toString(),
                    type: 'success' as MessageType,
                    content: `üìÇ Loaded project: ${project.name} (${projectFiles.length} files)`,
                    timestamp: new Date(),
                }]);
                setStatus('complete');

                // Mount files to WebContainer and start dev server
                const fsTree = toWebContainerFS(projectFiles);
                console.log('üå≥ [LOAD PROJECT] FileSystemTree created:', {
                    topLevelKeys: Object.keys(fsTree),
                    hasSrc: !!fsTree['src'],
                    srcContents: fsTree['src'] && 'directory' in fsTree['src'] ? Object.keys((fsTree['src'] as any).directory) : 'N/A'
                });

                await mountFiles(fsTree);
                console.log('‚úÖ [LOAD PROJECT] Files mounted, starting dev server...');
                await startDevServer();
            }
        } catch (err: any) {
            console.error('Failed to load project:', err);
            setMessages(prev => [...prev, {
                id: Date.now().toString(),
                type: 'error' as MessageType,
                content: `Failed to load project: ${err.message}`,
                timestamp: new Date(),
            }]);
        } finally {
            setIsLoadingProject(false);
            setStatusMessage(undefined);
        }
    };

    // Keep filesRef in sync
    useEffect(() => {
        filesRef.current = files;
    }, [files]);

    // Update file tree when files change
    useEffect(() => {
        if (files.length > 0) {
            const tree = buildFileTree(files);
            setFileTree(tree);
        }
    }, [files]);

    // Helper to add a message
    const addMessage = useCallback((type: MessageType, content: string, phase?: string, filesArr?: string[]) => {
        const message: AgentMessageData = {
            id: Date.now().toString(),
            type,
            content,
            timestamp: new Date(),
            phase,
            files: filesArr
        };
        setMessages(prev => [...prev, message]);
    }, []);

    // Update phase status
    const updatePhase = useCallback((id: string, status: ProcessingPhase['status'], filesCreated?: number) => {
        setPhases(prev => prev.map(p =>
            p.id === id ? { ...p, status, filesCreated: filesCreated ?? p.filesCreated } : p
        ));
    }, []);

    // Get or create session ID
    const getSessionId = () => {
        let sessionId = localStorage.getItem('sitecrafter_session_id');
        if (!sessionId) {
            sessionId = `session-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
            localStorage.setItem('sitecrafter_session_id', sessionId);
        }
        return sessionId;
    };

    // Save project to MongoDB
    const saveProject = useCallback(async (collectedFiles: { path: string; content: string }[]) => {
        try {
            const response = await axios.post(`${BACKEND_URL}/api/projects`, {
                sessionId: getSessionId(),
                prompt: pendingPrompt,
                files: collectedFiles,
                blueprint: blueprint,
            });

            if (response.data.success) {
                setProjectId(response.data.projectId);
                addMessage('success', `üíæ Project saved: ${response.data.name}`);
                console.log('Project saved with ID:', response.data.projectId);
            }
        } catch (err) {
            console.error('Failed to save project:', err);
        }
    }, [pendingPrompt, blueprint, addMessage]);

    // Handle file content changes from Monaco Editor
    const handleFileChange = useCallback(async (path: string, content: string) => {
        setFiles(prev => prev.map(f =>
            f.path === path ? { ...f, content } : f
        ));

        // Also update selectedFile if it's the currently selected one
        if (selectedFile?.path === path) {
            setSelectedFile(prev => prev ? { ...prev, content } : prev);
        }

        // Update the file in WebContainer (hot reload)
        if (isRunning) {
            await updateFile(path.replace(/^\//, ''), content);
        }

        // Auto-save to MongoDB (debounced)
        if (projectId) {
            // Clear any pending save
            if ((window as any).__saveTimeout) {
                clearTimeout((window as any).__saveTimeout);
            }
            // Debounce save - wait 2 seconds after last change
            (window as any).__saveTimeout = setTimeout(async () => {
                try {
                    await axios.patch(`${BACKEND_URL}/api/projects/${projectId}/files`, {
                        files: [{ path, content }]
                    });
                    console.log('‚úÖ Auto-saved to MongoDB:', path);
                } catch (err) {
                    console.error('‚ùå Auto-save failed:', err);
                }
            }, 2000);
        }
    }, [selectedFile?.path, updateFile, isRunning, projectId]);

    // Parse error from terminal output
    const parseError = useCallback((output: string[]): { file: string; error: string } | null => {
        const text = output.slice(-80).join('\n');

        // Vite import-analysis error (Failed to resolve import)
        const importMatch = text.match(/\[plugin:vite:import-analysis\]\s*Failed to resolve import\s*["']([^"']+)["']\s*from\s*["']([^"']+)["']/);
        if (importMatch) {
            const missingImport = importMatch[1];
            const sourceFile = importMatch[2];
            const filePath = sourceFile.replace(/^\//, '');
            console.log('üì¶ parseError: Import analysis error detected -', filePath);
            return {
                file: filePath,
                error: `Import Error: Cannot find module "${missingImport}" in ${sourceFile}.\nThis component needs to be created or the import path needs to be fixed.\n\nFull error:\n${text.slice(-600)}`,
            };
        }

        // Vite react-babel errors - New pattern matching actual format
        // Format: [plugin:vite:react-babel] /path/to/file.tsx: Error message (line:col)
        const babelMatch2 = text.match(/\[plugin:vite:react-babel\]\s*[^\n]*\/src\/([^\n:]+\.tsx?)[:\s]*\n?\s*(.+?)(?:\s*\(\d+:\d+\))?(?:\n|$)/s);
        if (babelMatch2) {
            const filePath = 'src/' + babelMatch2[1];
            const errorMsg = babelMatch2[2].trim();
            console.log('üîß parseError: Babel error detected -', filePath, '-', errorMsg);
            return {
                file: filePath,
                error: `Babel Syntax Error: ${errorMsg}\n\nFull error:\n${text.slice(-600)}`,
            };
        }

        // Alternative babel pattern
        const babelMatch = text.match(/\[plugin:vite:react-babel\]\s*([^\\n:]+\.tsx?):\s*(.+?)(?:\n|$)/);
        if (babelMatch) {
            const fileName = babelMatch[1].split('/').pop() || '';
            const fileMatch = text.match(new RegExp(`src/[\\w\\-\\/]*${fileName}`));
            console.log('üîß parseError: Alt babel error -', fileMatch?.[0] || fileName);
            return {
                file: fileMatch ? fileMatch[0] : `src/pages/${fileName}`,
                error: `Babel Syntax Error: ${babelMatch[2]}\n\nFull error:\n${text.slice(-600)}`,
            };
        }

        // ESBuild error
        const esbuildMatch = text.match(/\[plugin:vite:esbuild\]\s*([^\n:]+\.tsx?):(\\d+):(\\d+):\\s*(.+?)(?:\n|$)/);
        if (esbuildMatch) {
            const fileName = esbuildMatch[1].split('/').pop() || '';
            const fileMatch = text.match(new RegExp(`src/[\\w\\-\\/]*${fileName}`));
            console.log('üîß parseError: ESBuild error -', fileMatch?.[0] || fileName);
            return {
                file: fileMatch ? fileMatch[0] : `src/components/ui/${fileName}`,
                error: `ESBuild Error at line ${esbuildMatch[2]}: ${esbuildMatch[4]}\n\nFull error:\n${text.slice(-600)}`,
            };
        }

        // TypeScript error
        const tsMatch = text.match(/(src\/[\w\-\/]+\.tsx?)\((\d+),(\d+)\):\s*error\s*(TS\d+):\s*(.+?)(?:\n|$)/);
        if (tsMatch) {
            console.log('üîß parseError: TypeScript error -', tsMatch[1]);
            return {
                file: tsMatch[1],
                error: `TypeScript Error ${tsMatch[4]} at line ${tsMatch[2]}: ${tsMatch[5]}\n\nFull error:\n${text.slice(-600)}`,
            };
        }

        // JSX closing tag error - specific pattern
        const jsxMatch = text.match(/Expected corresponding JSX closing tag for <([^>]+)>/);
        if (jsxMatch) {
            const fileMatch = text.match(/\/src\/([^\n:]+\.tsx?)/);
            if (fileMatch) {
                const filePath = 'src/' + fileMatch[1];
                console.log('üîß parseError: JSX tag error -', filePath);
                return {
                    file: filePath,
                    error: `JSX Syntax Error: Expected corresponding JSX closing tag for <${jsxMatch[1]}>\n\nFull error:\n${text.slice(-600)}`,
                };
            }
        }

        // Generic syntax errors
        if (text.includes('Unexpected token') || text.includes('unexpected token')) {
            const fileMatch = text.match(/(?:src\/[\w\-\/]+\.tsx?)/);
            if (fileMatch) {
                console.log('üîß parseError: Syntax error -', fileMatch[0]);
                return { file: fileMatch[0], error: `Syntax Error:\n${text.slice(-600)}` };
            }
        }

        // Module not found - improved pattern
        const moduleMatch = text.match(/(?:Cannot find module|Failed to resolve|Module not found)[:\s]*["']([^"']+)["']/i);
        if (moduleMatch) {
            const fileMatch = text.match(/(?:src\/[\w\-\/]+\.tsx?)/);
            if (fileMatch) {
                console.log('üîß parseError: Module not found -', fileMatch[0]);
                return {
                    file: fileMatch[0],
                    error: `Module not found: ${moduleMatch[1]}\n\nFull error:\n${text.slice(-600)}`,
                };
            }
        }

        return null;
    }, []);

    // Fix code error using LLM
    const fixCodeError = useCallback(async (errorFile: string, errorText: string) => {
        if (fixingRef.current) {
            console.log('‚è≥ Fix already in progress, skipping');
            return false;
        }

        // Use time-based cooldown per file (30 seconds before retrying same file)
        const fileKey = errorFile;
        const lastAttemptTime = (fixedFilesRef.current as any).get?.(fileKey) || 0;
        const cooldownMs = 30000; // 30 seconds cooldown per file
        const now = Date.now();

        if (now - lastAttemptTime < cooldownMs) {
            console.log(`‚è≥ Cooldown for ${errorFile}, retry in ${Math.ceil((cooldownMs - (now - lastAttemptTime)) / 1000)}s`);
            return false;
        }

        // Mark as fixing IMMEDIATELY to prevent race conditions
        fixingRef.current = true;
        // Use Map for time-based tracking instead of Set
        if (!(fixedFilesRef.current instanceof Map)) {
            fixedFilesRef.current = new Map() as any;
        }
        (fixedFilesRef.current as any).set(fileKey, now);
        setIsFixing(true);

        // Show user what's being fixed
        const shortError = errorText.split('\n')[0].slice(0, 100);
        const attemptNum = fixCount + 1;
        addMessage('thinking', `üîß [Attempt ${attemptNum}] Auto-fixing: ${errorFile}\n${shortError}...`);
        console.log(`üîß Auto-fix started: ${errorFile} - Fix #${attemptNum}`);


        try {
            // Check if this is a "missing component" error
            const missingImportMatch = errorText.match(/Cannot find module ["']([^"']+)["']|Failed to resolve import ["']([^"']+)["']/i);

            if (missingImportMatch) {
                const missingPath = missingImportMatch[1] || missingImportMatch[2];
                console.log('üÜï Missing import detected:', missingPath);

                // Skip non-component imports (CSS, images, packages)
                if (missingPath.endsWith('.css') ||
                    missingPath.endsWith('.scss') ||
                    missingPath.endsWith('.png') ||
                    missingPath.endsWith('.jpg') ||
                    missingPath.endsWith('.svg') ||
                    !missingPath.includes('/')) { // packages like 'react' don't have /
                    console.log('‚è≠Ô∏è Skipping non-component import:', missingPath);
                    fixingRef.current = false;
                    setIsFixing(false);
                    return false;
                }

                // Extract component name and path
                const componentName = missingPath.split('/').pop()?.replace(/\.(tsx?|jsx?)$/, '') || 'Component';
                let filePath = missingPath;

                // Handle @/ alias
                if (filePath.startsWith('@/')) {
                    filePath = filePath.replace('@/', 'src/');
                }
                if (!filePath.endsWith('.tsx') && !filePath.endsWith('.ts')) {
                    filePath += '.tsx';
                }
                if (!filePath.startsWith('src/')) {
                    filePath = 'src/' + filePath;
                }

                addMessage('thinking', `üÜï Creating missing component: ${componentName}...`);

                // Generate a simple component using LLM
                const response = await fetch(`${BACKEND_URL}/api/fix-error`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        error: `Create a new React component for: ${componentName}. The file path is ${filePath}. Make it a functional TypeScript component with proper props interface and modern styling using Tailwind CSS.`,
                        filePath: filePath,
                        fileContent: '// NEW FILE - GENERATE COMPONENT',
                    }),
                });

                if (response.ok) {
                    const { fixedCode } = await response.json();
                    if (fixedCode) {
                        // Add to files state
                        setFiles(prev => [...prev, { path: '/' + filePath, content: fixedCode }]);

                        // Write to WebContainer
                        await updateFile(filePath, fixedCode);

                        // Save new component to MongoDB
                        if (projectId) {
                            try {
                                await axios.patch(`${BACKEND_URL}/api/projects/${projectId}/files`, {
                                    files: [{ path: '/' + filePath, content: fixedCode }]
                                });
                                console.log('üíæ New component saved to MongoDB:', filePath);
                            } catch (saveErr) {
                                console.error('Failed to save component to MongoDB:', saveErr);
                            }
                        }

                        setFixCount(prev => prev + 1);
                        addMessage('success', `‚úÖ Created & saved: ${componentName}`);
                        return true;
                    }
                }
            }

            // Standard fix for existing files
            let targetFile = filesRef.current.find(f =>
                f.path === errorFile ||
                f.path.endsWith(errorFile) ||
                f.path.includes(errorFile.replace('src/', ''))
            );

            if (!targetFile?.content) {
                const fileName = errorFile.split('/').pop();
                if (fileName) {
                    targetFile = filesRef.current.find(f => f.path.endsWith(fileName));
                }
            }

            if (!targetFile?.content) {
                console.warn(`File not found: ${errorFile}`);
                return false;
            }

            console.log(`üîß Fixing code in: ${targetFile.path}`);
            addMessage('thinking', `üîß Auto-fixing error in ${targetFile.path}...`);

            const response = await fetch(`${BACKEND_URL}/api/fix-error`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    error: errorText,
                    filePath: targetFile.path,
                    fileContent: targetFile.content,
                }),
            });

            if (!response.ok) throw new Error('Backend failed');

            const { fixedCode } = await response.json();

            if (fixedCode && fixedCode !== targetFile.content) {
                // Update file in state
                setFiles(prev => prev.map(f =>
                    f.path === targetFile!.path ? { ...f, content: fixedCode } : f
                ));

                // Update file in WebContainer
                await updateFile(targetFile.path.replace(/^\//, ''), fixedCode);

                // Save fixed code to MongoDB if project exists
                if (projectId) {
                    console.log('üíæ Saving fix to MongoDB... Project:', projectId, 'File:', targetFile.path);
                    try {
                        const saveResponse = await axios.patch(`${BACKEND_URL}/api/projects/${projectId}/files`, {
                            files: [{ path: targetFile.path, content: fixedCode }]
                        });
                        console.log('‚úÖ SAVED TO DATABASE:', targetFile.path, '- Response:', saveResponse.data);
                        addMessage('success', `‚úÖ Fixed & saved to database: ${targetFile.path}`);
                    } catch (saveErr: any) {
                        console.error('‚ùå FAILED TO SAVE TO DATABASE:', saveErr.response?.data || saveErr.message);
                        addMessage('error', `‚ö†Ô∏è Fixed but failed to save: ${targetFile.path}`);
                    }
                } else {
                    console.log('‚ö†Ô∏è No projectId, cannot save to MongoDB');
                    addMessage('success', `‚úÖ Fixed (not saved - no project): ${targetFile.path}`);
                }

                setFixCount(prev => prev + 1);
                return true;
            }
        } catch (err) {
            console.error('Fix failed:', err);
            addMessage('error', `‚ùå Auto-fix failed: ${err}`);
        } finally {
            fixingRef.current = false;
            setIsFixing(false);
        }
        return false;
    }, [addMessage, updateFile, projectId]);

    // Watch terminal output for errors and auto-fix
    useEffect(() => {
        if (!isRunning || fixingRef.current || isFixing) return;
        if (fixAttempts.current >= MAX_FIX_ATTEMPTS) return;

        const text = terminalOutput.slice(-50).join('\n');

        // Check for common error patterns
        const hasError = text.includes('[plugin:vite') ||
            text.includes('error') ||
            text.includes('Error') ||
            text.includes('failed') ||
            text.includes('Failed');

        if (hasError) {
            console.log('üîç Detected potential error in terminal output:', text.slice(-500));
        }

        const errorInfo = parseError(terminalOutput);
        if (errorInfo && errorInfo.file) {
            console.log('üîß Auto-fix triggered for:', errorInfo.file, errorInfo.error.slice(0, 200));
            const timeoutId = setTimeout(() => {
                fixCodeError(errorInfo.file, errorInfo.error);
            }, 1500);

            return () => clearTimeout(timeoutId);
        }
    }, [terminalOutput, isRunning, isFixing, parseError, fixCodeError]);

    // Listen for runtime errors from preview iframe
    useEffect(() => {
        const handleRuntimeError = (event: MessageEvent) => {
            if (event.data?.type !== 'RUNTIME_ERROR') return;
            if (!isRunning || fixingRef.current || isFixing) return;
            if (fixAttempts.current >= MAX_FIX_ATTEMPTS) return;

            const { message, stack, errorType } = event.data;
            console.log('üî¥ Runtime error received:', { message, stack, errorType });

            const { filePath } = parseStackTrace(stack || '');

            if (filePath) {
                const errorContext = `Runtime Error (${errorType})\n${message}\n\nStack trace:\n${stack}`;
                setTimeout(() => {
                    fixCodeError(filePath, errorContext);
                }, 1500);
            } else {
                console.warn('Could not extract file path from runtime error:', stack);
            }
        };

        window.addEventListener('message', handleRuntimeError);
        return () => window.removeEventListener('message', handleRuntimeError);
    }, [isRunning, isFixing, fixCodeError]);

    // Handle send message - Using SSE for real-time streaming
    const handleSendMessage = useCallback(async (userMessage: string) => {
        // Add user message
        addMessage('user', userMessage);

        // Check if this is a follow-up modification (project already exists)
        if (projectId && files.length > 0) {
            setIsProcessing(true);
            setStatusMessage('Analyzing modification request...');
            addMessage('thinking', 'üîç Analyzing which files need to be modified...');

            try {
                const response = await axios.post(`${BACKEND_URL}/api/projects/${projectId}/modify`, {
                    modificationRequest: userMessage,
                });

                if (response.data.success && response.data.modifiedFiles?.length > 0) {
                    const modifiedFiles = response.data.modifiedFiles;

                    // Update files in state
                    for (const modified of modifiedFiles) {
                        const path = modified.path.startsWith('/') ? modified.path : '/' + modified.path;

                        setFiles(prev => {
                            const existing = prev.find(f => f.path === path);
                            if (existing) {
                                return prev.map(f => f.path === path ? { ...f, content: modified.content } : f);
                            } else {
                                return [...prev, { path, content: modified.content }];
                            }
                        });

                        // Update in WebContainer
                        await updateFile(modified.path.replace(/^\//, ''), modified.content);
                    }

                    addMessage('success', `‚úÖ Modified ${modifiedFiles.length} file(s): ${response.data.summary}`);
                } else {
                    addMessage('progress', 'No modifications were needed.');
                }
            } catch (err: any) {
                addMessage('error', `Modification failed: ${err.message}`);
            } finally {
                setIsProcessing(false);
                setStatusMessage(undefined);
            }
            return;
        }

        // New project - Reset state
        setPhases(prev => prev.map(p => ({ ...p, status: 'pending', filesCreated: 0 })));
        setFiles([]);
        setFileTree([]);
        setSelectedFile(null);
        setFixCount(0);
        fixAttempts.current = 0;
        fixedFilesRef.current.clear();
        setProjectId(null);

        // Set processing state
        setIsProcessing(true);
        setStatus('running');
        setStatusMessage('Generating architecture plan...');

        // Add thinking message
        addMessage('thinking', "I'm analyzing your requirements and planning the website structure...");

        try {
            updatePhase('blueprint', 'in-progress');

            // Call /planning endpoint to get blueprint for review
            const response = await axios.post(`${BACKEND_URL}/planning`, {
                requirements: userMessage.trim(),
                projectType: 'frontend'
            });

            if (response.data.success && response.data.data?.blueprint) {
                setBlueprint(response.data.data.blueprint);
                setPendingPrompt(userMessage);
                setShowPlanningReview(true);
                updatePhase('blueprint', 'complete');
                setIsProcessing(false);
                addMessage('success', `üìã Planning complete! Review the architecture.`);
                setStatusMessage('Review the plan and approve to start coding');
                return; // Exit here - handleApproveAndContinue takes over after user approval
            }
        } catch (error: any) {
            console.error('Planning error:', error);
            addMessage('error', `Planning failed: ${error.message || 'Unknown error'}`);
            setStatus('error');
            setStatusMessage(error.message);
        } finally {
            setIsProcessing(false);
        }
    }, [addMessage, updatePhase, projectId, files.length, updateFile]);

    // Handle stop
    const handleStop = useCallback(() => {
        if (abortControllerRef.current) {
            abortControllerRef.current.abort();
        }
    }, []);

    // Handle approve planning and start code generation
    const handleApproveAndContinue = useCallback(async () => {
        if (!blueprint) return;
        setShowPlanningReview(false);
        setIsProcessing(true);
        setStatus('running');
        addMessage('thinking', 'Starting code generation from approved plan...');

        // Trigger the existing SSE generation with the detailedContext
        const prompt = blueprint.detailedContext || pendingPrompt;

        try {
            abortControllerRef.current = new AbortController();
            updatePhase('core', 'in-progress');
            setStatusMessage('Generating code...');

            const response = await fetch(`${BACKEND_URL}/chat/langgraph-stream`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt, projectType: 'frontend' }),
                signal: abortControllerRef.current.signal
            });

            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

            const reader = response.body?.getReader();
            const decoder = new TextDecoder();
            let componentCount = 0, pageCount = 0, totalFiles = 0;
            const collected: { path: string; content: string }[] = [];

            if (reader) {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n').filter(l => l.startsWith('data: '));

                    for (const line of lines) {
                        try {
                            const data = JSON.parse(line.slice(6));
                            if (data.type === 'file') {
                                totalFiles++;
                                const path = data.path.startsWith('/') ? data.path : '/' + data.path;
                                collected.push({ path, content: data.content });
                                setFiles(prev => [...prev, { path, content: data.content }]);
                                if (data.phase === 'components') componentCount++;
                                else if (data.phase === 'page') pageCount++;
                            } else if (data.type === 'phase') {
                                setStatusMessage(data.message);
                            } else if (data.type === 'complete') {
                                setStatus('complete');
                                addMessage('success', `‚úÖ Generated ${totalFiles} files!`);
                                if (collected.length > 0) {
                                    const fsTree = toWebContainerFS(collected);
                                    await mountFiles(fsTree);
                                    await startDevServer();
                                    // Save project to MongoDB
                                    await saveProject(collected);
                                }
                            }
                        } catch { }
                    }
                }
            }
        } catch (e: any) {
            addMessage('error', e.message);
            setStatus('error');
        } finally {
            setIsProcessing(false);
        }
    }, [blueprint, pendingPrompt, addMessage, updatePhase, mountFiles, startDevServer, saveProject]);

    // Handle reject planning
    const handleRejectPlan = useCallback(() => {
        setShowPlanningReview(false);
        setBlueprint(null);
        setPendingPrompt('');
        setStatus('idle');
        addMessage('progress', 'Plan rejected. Try a different prompt.');
    }, [addMessage]);

    // Handle file select
    const handleSelectFile = useCallback((file: FileNode) => {
        if (file.type === 'file') {
            const fullFile = files.find(f => f.path === file.path);
            setSelectedFile({
                ...file,
                content: fullFile?.content || file.content
            });
        }
    }, [files]);

    // Handle download
    const handleDownload = useCallback(async () => {
        if (files.length === 0) return;

        const zip = new JSZip();

        files.forEach(file => {
            const path = file.path.replace(/^\//, '');
            zip.file(path, file.content);
        });

        const blob = await zip.generateAsync({ type: 'blob' });
        saveAs(blob, 'sitecrafter-project.zip');

        addMessage('success', 'Project downloaded successfully!');
    }, [files, addMessage]);

    return (
        <div className="flex flex-col h-screen bg-[#0a0a0a] text-white relative">
            {/* Header */}
            <header className="flex items-center justify-between px-4 py-3 border-b border-[#2e2e2e] bg-[#141414]">
                <div className="flex items-center gap-4">
                    <button
                        onClick={() => navigate('/dashboard')}
                        className="p-2 hover:bg-[#2e2e2e] rounded-lg transition-colors"
                    >
                        <ArrowLeft className="w-5 h-5 text-gray-400" />
                    </button>
                    <div className="flex items-center gap-2">
                        <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-amber-500 to-teal-600 flex items-center justify-center">
                            <Sparkles className="w-4 h-4 text-white" />
                        </div>
                        <span className="font-semibold text-gray-100">SiteCrafter Agent</span>
                    </div>
                </div>

                <div className="flex items-center gap-4">
                    {/* WebContainer Status */}
                    <div className="flex items-center gap-2 text-xs">
                        {isPreWarmed && !isPreWarming && (
                            <span className="flex items-center gap-1 px-2 py-1 bg-amber-500/10 rounded-full text-amber-500">
                                <Zap className="w-3 h-3" />
                                Ready
                            </span>
                        )}
                        {isFixing && (
                            <span className="flex items-center gap-1 px-2 py-1 bg-orange-500/10 rounded-full text-orange-500">
                                <Loader2 className="w-3 h-3 animate-spin" />
                                Auto-fixing...
                            </span>
                        )}
                        {fixCount > 0 && (
                            <span className="px-2 py-1 bg-amber-500/10 rounded-full text-amber-400">
                                {fixCount} {fixCount === 1 ? 'fix' : 'fixes'}
                            </span>
                        )}
                    </div>

                    {/* My Projects Button */}
                    <button
                        onClick={() => navigate('/projects')}
                        className="flex items-center gap-2 px-3 py-1.5 bg-white/5 hover:bg-white/10 rounded-lg text-sm text-gray-300 hover:text-white transition-all"
                    >
                        <FolderOpen className="w-4 h-4" />
                        My Projects
                    </button>

                    <span className="text-xs text-gray-500">Powered by LangGraph + Gemini</span>
                </div>
            </header>

            {/* Planning Review Overlay */}
            {showPlanningReview && blueprint && (
                <PlanningReview
                    blueprint={blueprint}
                    onApprove={handleApproveAndContinue}
                    onReject={handleRejectPlan}
                />
            )}

            {/* Main Content */}
            <div className="flex-1 flex overflow-hidden">
                {/* Chat Panel - Left Side */}
                <div className="w-1/2 flex flex-col border-r border-[#2e2e2e]">
                    <ChatPanel
                        messages={messages}
                        phases={phases}
                        status={status}
                        statusMessage={statusMessage}
                        onSendMessage={handleSendMessage}
                        onStop={handleStop}
                        isProcessing={isProcessing}
                    />
                </div>

                {/* Preview Panel - Right Side */}
                <div className="w-1/2 flex flex-col">
                    <PreviewPanel
                        files={fileTree}
                        selectedFile={selectedFile}
                        onSelectFile={handleSelectFile}
                        onFileChange={handleFileChange}
                        previewUrl={wcPreviewUrl || undefined}
                        isLoading={isProcessing || isInstalling || isBooting}
                        totalFiles={files.length}
                        onDownload={handleDownload}
                        terminalOutput={terminalOutput}
                        isInstalling={isInstalling}
                        isBooting={isBooting}
                    />
                </div>
            </div>
        </div>
    );
};

export default AgentBuilder;
